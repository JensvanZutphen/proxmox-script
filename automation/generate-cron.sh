#!/bin/bash
# Generate Automation Cron Jobs
# This script generates cron jobs based on automation configuration

set -euo pipefail

# Source utilities and configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Safe sourcing with fallback logging
for f in "$SCRIPT_DIR/../lib/utils.sh" "/etc/proxmox-health/automation.conf"; do
    if [ -r "$f" ]; then
        # Validate system config file ownership/permissions before sourcing
        if [ "$f" = "/etc/proxmox-health/automation.conf" ] && command -v stat >/dev/null 2>&1; then
            owner_uid=$(stat -c '%u' "$f" 2>/dev/null || echo '')
            perms=$(stat -c '%a' "$f" 2>/dev/null || echo '000')
            grp_digit=$(( (10#$perms / 10) % 10 ))
            oth_digit=$(( 10#$perms % 10 ))
            if { [ "$owner_uid" != "0" ] && [ "$owner_uid" != "$(id -u)" ]; } || \
               { [ $((grp_digit & 2)) -ne 0 ] || [ $((oth_digit & 2)) -ne 0 ]; }; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] Unsafe config file: $f (owner_uid=$owner_uid perms=$perms)" >&2
                continue
            fi
        fi
        source "$f"
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [WARNING] Optional file not readable: $f" >&2
    fi
done

# --- Configuration ---
CRON_FILE="/etc/cron.d/proxmox-automation"
SCRIPT_INSTALL_DIR="/usr/local/lib/proxmox-health/automation"

# log_info writes an informational message prefixed with an ISO-like timestamp and "[INFO]" tag to stderr.
log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] $1" >&2
}

# log_warning outputs a timestamped warning message to stderr (accepts the message as its first argument).
log_warning() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [WARNING] $1" >&2
}

# log_error writes a timestamped error message to stderr in the format "[YYYY-MM-DD HH:MM:SS] [ERROR] <message>".
log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] $1" >&2
}

# log_debug writes a timestamped debug message to stderr when AUTOMATION_LOG_LEVEL is set to "DEBUG".
log_debug() {
    if [ "${AUTOMATION_LOG_LEVEL:-INFO}" = "DEBUG" ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [DEBUG] $1" >&2
    fi
}

# validate_cron_schedule validates a cron schedule string consisting of five space-separated fields.
# It returns 0 when the schedule appears valid and 1 otherwise. Accepts numeric values, ranges, lists,
# wildcards (`*`), step values (`/`), and commas as supported cron field constructs.
validate_cron_schedule() {
    local schedule="$1"

    # Basic validation for cron schedule (5 fields)
    if [[ "$schedule" =~ ^[0-9*/,-]+\s+[0-9*/,-]+\s+[0-9*/,-]+\s+[0-9*/,-]+\s+[0-9*/,-]+$ ]]; then
        return 0
    else
        return 1
    fi
}

# generate_cron_jobs generates the /etc/cron.d/proxmox-automation file from the loaded automation configuration, validating schedules, adding enabled job entries and environment variables, installs the file to /etc/cron.d/proxmox-automation and sets permissions to 644.
generate_cron_jobs() {
    log_info "Generating automation cron jobs"

    # Create temporary file
    local temp_file
    temp_file=$(mktemp)

    # Generate cron file header
    cat > "$temp_file" << 'EOF'
# Proxmox Health Monitoring - Automation Jobs
# Generated by proxmox-health automation system
# Do not edit this file directly - use the TUI to modify automation settings

EOF

    # Add environment variables for automation scripts
    cat >> "$temp_file" << 'EOF'
# Environment variables for automation scripts
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
AUTOMATION_LOG_LEVEL=INFO
CONFIG_DIR=/etc/proxmox-health
STATE_DIR=/var/tmp/proxmox-health
LOG_DIR=/var/log/proxmox-health

EOF

    # Function to add cron job if enabled
    add_cron_job() {
        local enabled_var="$1"
        local schedule_var="$2"
        local script_name="$3"
        local script_args="$4"

        if [ "${!enabled_var:-no}" = "yes" ]; then
            local schedule="${!schedule_var:-}"

            if [ -n "$schedule" ] && validate_cron_schedule "$schedule"; then
                echo "# $script_name" >> "$temp_file"
                echo "$schedule root $SCRIPT_INSTALL_DIR/$script_name $script_args" >> "$temp_file"
                echo "" >> "$temp_file"
                log_info "Added cron job for $script_name: $schedule"
            else
                log_warning "Invalid or empty cron schedule for $script_name: $schedule"
            fi
        else
            log_debug "Skipping disabled cron job for $script_name"
        fi
    }

    # Add individual cron jobs based on configuration
    add_cron_job "AUTOMATION_ZFS_CLEANUP_ENABLED" "AUTOMATION_ZFS_CLEANUP_SCHEDULE" "zfs-cleanup.sh" ""
    add_cron_job "AUTOMATION_DISK_CLEANUP_ENABLED" "AUTOMATION_DISK_CLEANUP_SCHEDULE" "disk-cleanup.sh" ""
    add_cron_job "AUTOMATION_MEMORY_RELIEF_ENABLED" "AUTOMATION_MEMORY_RELIEF_SCHEDULE" "memory-relief.sh" ""
    add_cron_job "AUTOMATION_SYSTEM_REFRESH_ENABLED" "AUTOMATION_SYSTEM_REFRESH_SCHEDULE" "system-refresh.sh" ""
    add_cron_job "AUTOMATION_AUTO_UPDATE_ENABLED" "AUTOMATION_AUTO_UPDATE_SCHEDULE" "auto-update.sh" ""

    # Add log rotation for automation logs
    cat >> "$temp_file" << 'EOF'
# Log rotation for automation logs
0 2 * * * root if [ -f /var/log/proxmox-health/auto-update.log ]; then > /var/log/proxmox-health/auto-update.log; fi

EOF

    # Install cron file
    if [ "${EUID:-$(id -u)}" -ne 0 ]; then
        log_error "Root privileges required to install $CRON_FILE"
        rm -f "$temp_file" || true
        return 1
    fi
    install -m 0644 -o root -g root "$temp_file" "$CRON_FILE"
    rm -f "$temp_file" || true

    log_info "Automation cron jobs generated and installed to $CRON_FILE"
}

# remove_cron_jobs removes the generated automation cron file at $CRON_FILE if present and logs the outcome.
remove_cron_jobs() {
    log_info "Removing automation cron jobs"

    if [ -f "$CRON_FILE" ]; then
        rm -f "$CRON_FILE"
        log_info "Removed automation cron file: $CRON_FILE"
    else
        log_debug "No automation cron file found"
    fi
}

# reload_cron_service reloads the system cron daemon (tries `cron` then `crond`) via systemctl if active; logs a warning if no active cron service can be determined.
reload_cron_service() {
    log_info "Reloading cron service"

    if systemctl is-active --quiet cron; then
        systemctl reload cron
        log_info "Cron service reloaded"
    elif systemctl is-active --quiet crond; then
        systemctl reload crond
        log_info "Cron service reloaded"
    else
        log_warning "Could not determine cron service status"
    fi
}

# show_cron_jobs prints the generated automation cron file ($CRON_FILE, typically /etc/cron.d/proxmox-automation) to stdout if it exists; otherwise prints a message that no automation cron jobs are found.
show_cron_jobs() {
    log_info "Current automation cron jobs:"

    if [ -f "$CRON_FILE" ]; then
        echo ""
        echo "=== Automation Cron Jobs ==="
        cat "$CRON_FILE"
    else
        echo "No automation cron jobs found"
    fi
}

# validate_cron_jobs validates the generated cron file at $CRON_FILE, checking each job's 5-field schedule and whether the referenced script exists.
# If the cron file is absent it logs a warning and returns 0. If the file is unreadable or any schedules are invalid it logs errors and returns 1.
# For each non-empty, non-comment line it extracts the first five fields and calls validate_cron_schedule; it also checks the 7th field for the script path and logs a warning if that script is missing.
validate_cron_jobs() {
    local errors=0

    if [ ! -f "$CRON_FILE" ]; then
        log_warning "No automation cron file found"
        return 0
    fi

    # Check if cron file is readable
    if [ ! -r "$CRON_FILE" ]; then
        log_error "Cron file is not readable: $CRON_FILE"
        return 1
    fi

    # Validate each cron job
    local line_number=0
    while IFS= read -r line; do
        line_number=$((line_number + 1))

        # Skip comments and empty lines
        [[ "$line" =~ ^# ]] && continue
        [[ "$line" =~ ^$ ]] && continue
        # Skip environment/variable assignment lines
        if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
            continue
        fi
        # Guard: only process lines that start with 5 cron fields or @shortcuts
        if ! [[ "$line" =~ ^([0-9*/,-]+[[:space:]]+){5} || "$line" =~ ^@(reboot|yearly|annually|monthly|weekly|daily|hourly)[[:space:]]+ ]]; then
            continue
        fi

        local schedule script_field
        if [[ "$line" =~ ^@(reboot|yearly|annually|monthly|weekly|daily|hourly)[[:space:]]+ ]]; then
            # @-shortcut form: "@reboot USER CMD..."; user=$2, command=$3
            schedule="$(echo "$line" | awk '{print $1}')"
            script_field=3
        else
            # Standard 5-field form: "m h dom mon dow USER CMD..."
            schedule="$(echo "$line" | awk '{print $1" "$2" "$3" "$4" "$5}')"
            script_field=7
            if ! validate_cron_schedule "$schedule"; then
                log_error "Invalid cron schedule at line $line_number: $schedule"
                errors=$((errors + 1))
            fi
        fi

        # Check if script exists and is executable (only for absolute paths or SCRIPT_INSTALL_DIR paths)
        local script_path
        script_path=$(awk -v n="$script_field" '{print $n}' <<<"$line")

        # Remove surrounding quotes if present
        script_path=${script_path#\"}
        script_path=${script_path%\"}
        script_path=${script_path#\'}
        script_path=${script_path%\'}

        # Normalize SCRIPT_INSTALL_DIR for comparison (remove trailing slash)
        local normalized_install_dir="${SCRIPT_INSTALL_DIR%/}"

        # Only validate paths that are absolute or start with SCRIPT_INSTALL_DIR
        if [ -n "$script_path" ] && [[ "$script_path" == /* || "$script_path" == "$normalized_install_dir"* ]]; then
            if [ ! -x "$script_path" ]; then
                if [ -f "$script_path" ]; then
                    log_warning "Script not executable: $script_path (line $line_number)"
                else
                    log_warning "Script not found: $script_path (line $line_number)"
                fi
            fi
        fi

    done < "$CRON_FILE"

    if [ "$errors" -gt 0 ]; then
        log_error "Cron validation failed with $errors errors"
        return 1
    else
        log_info "Cron validation passed"
        return 0
    fi
}

# show_help displays usage information, available options, examples, and configuration notes for the automation cron management script.
show_help() {
    cat << EOF
Generate Automation Cron Jobs

Usage: $0 [OPTIONS]

Options:
  -h, --help          Show this help message
  -g, --generate      Generate cron jobs from configuration
  -r, --remove        Remove all automation cron jobs
  -s, --show          Show current automation cron jobs
  -v, --validate      Validate current cron jobs
  -l, --reload        Reload cron service
  -c, --config FILE   Use specific configuration file

Examples:
  $0 --generate       # Generate cron jobs from current configuration
  $0 --show           # Show current cron jobs
  $0 --validate       # Validate cron jobs
  $0 --remove         # Remove all automation cron jobs

Configuration:
  The script reads automation configuration from /etc/proxmox-health/automation.conf
  Cron jobs are generated based on enabled automation tasks and their schedules.
EOF
}

# main parses command-line options, dispatches the requested action (generate, remove, show, validate, reload) for managing automation cron jobs, and exits with an appropriate status.
main() {
    local action="generate"
    local verbose="no"

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -g|--generate)
                action="generate"
                shift
                ;;
            -r|--remove)
                action="remove"
                shift
                ;;
            -s|--show)
                action="show"
                shift
                ;;
            -v|--validate)
                action="validate"
                shift
                ;;
            -l|--reload)
                action="reload"
                shift
                ;;
            -c|--config)
                shift
                if [ -z "${1:-}" ]; then
                    log_error "Missing argument for --config"
                    exit 1
                fi
                if [ ! -r "$1" ]; then
                    log_error "Config file not found or not readable: $1"
                    exit 1
                fi
                # Ownership/perms: root or current user; not group/other writable
                if command -v stat >/dev/null 2>&1; then
                  owner_uid=$(stat -c '%u' "$1" 2>/dev/null || echo '')
                  perms=$(stat -c '%a' "$1" 2>/dev/null || echo '000')
                  cur_uid=$(id -u)
                  grp_digit=$(( (10#$perms / 10) % 10 ))
                  oth_digit=$(( 10#$perms % 10 ))
                  if { [ "$owner_uid" != "$cur_uid" ] && [ "$owner_uid" != "0" ]; } || \
                     { [ $((grp_digit & 2)) -ne 0 ] || [ $((oth_digit & 2)) -ne 0 ]; }; then
                    log_error "Unsafe config file permissions/owner: $1 (owner_uid=$owner_uid perms=$perms)"
                    exit 1
                  fi
                fi
                source "$1"
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                shift
                ;;
        esac
    done

    log_info "Starting automation cron job management (action: $action)"

    case "$action" in
        generate)
            generate_cron_jobs
            reload_cron_service
            ;;
        remove)
            remove_cron_jobs
            reload_cron_service
            ;;
        show)
            show_cron_jobs
            ;;
        validate)
            if validate_cron_jobs; then
                log_info "All cron jobs are valid"
                exit 0
            else
                exit 1
            fi
            ;;
        reload)
            reload_cron_service
            ;;
        *)
            log_error "Unknown action: $action"
            show_help
            exit 1
            ;;
    esac

    log_info "Automation cron job management completed"
    exit 0
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi